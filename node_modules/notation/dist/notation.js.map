{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 2440b834419b4867c50b","webpack:///./src/index.js","webpack:///./src/core/Notation.js","webpack:///./src/lib/utils.js","webpack:///./src/core/notation.glob.js","webpack:///./src/core/notation.error.js"],"names":[],"mappings":"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","file":"notation.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"notation\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"notation\"] = factory();\n\telse\n\t\troot[\"notation\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 2440b834419b4867c50b\n **/","import Notation from './core/Notation';\n// export default Notation;\n// http://stackoverflow.com/a/33683495/112731\nmodule.exports = Notation;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","import utils from '../lib/utils';\nimport NotationGlob from './notation.glob';\nimport NotationError from './notation.error';\n\n// TODO:\n// templates? ${some.property}\n// Error if source object has flattened (dotted) keys.\n// expand if dotted keyed object is passed to constructor?\n\n// https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors\n\nconst ERR = {\n    SOURCE: 'Invalid source object.',\n    DEST: 'Invalid destination object.',\n    NOTATION: 'Invalid notation: ',\n    NOTA_OBJ: 'Invalid notations object: '\n};\n\n/**\n *  Notation.js for Node and Browser.\n *\n *  Like in most programming languages, JavaScript makes use of dot-notation to\n *  access the value a member of an object (or class). `Notation` class provides\n *  various methods for modifying / processing the contents of the given object;\n *  by parsing object notation strings or globs.\n *\n *  Note that this class will only deal with enumerable properties of the\n *  source object; so it should be used to manipulate data objects. It will\n *  not deal with preserving the prototype-chain of the given object.\n *\n *  @author   Onur Yıldırım (onur@cutepilot.com)\n *  @license  MIT\n */\nclass Notation {\n\n    /**\n     *  Initializes a new instance of `Notation`.\n     *\n     *  @param {Object} [object={}] - The source object to be notated.\n     *\n     *  @example\n     *  var obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  var notation = new Notation(obj);\n     *  notation.get('car.model'); // \"Charger\"\n     */\n    constructor(object = {}) {\n        // if defined, it should be an object.\n        if (!utils.isObject(object)) {\n            throw new NotationError(ERR.SOURCE);\n        }\n        this._source = object;\n    }\n\n    // --------------------------------\n    // Notation Instance Properties\n    // --------------------------------\n\n    /**\n     *  Gets the value of the source object.\n     *  @type {Object}\n     *\n     *  @example\n     *  var person = { name: \"Onur\" };\n     *  var me = Notation.create(person)\n     *      .set(\"age\", 36)\n     *      .set(\"car.brand\", \"Ford\")\n     *      .set(\"car.model\", \"Mustang\")\n     *      .value;\n     *  console.log(me); // { name: \"Onur\", age: 36, car: { brand: \"Ford\", model: \"Mustang\" } }\n     *  console.log(person === me); // true\n     */\n    get value() {\n        return this._source;\n    }\n\n    // --------------------------------\n    // Notation Instance Methods\n    // --------------------------------\n\n    /**\n     *  Recursively iterates through each key of the source object and invokes\n     *  the given callback function with parameters, on each non-object value.\n     *  @alias Notation#eachKey\n     *\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each on each non-object value. To break out of the loop, return `false`\n     *  from within the callback.\n     *  Callback signature: `callback(notation, key, value, object) { ... }`\n     *\n     *  @returns {void}\n     *\n     *  @example\n     *  var obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  Notation.create(obj).each(function (notation, key, value, object) {\n     *      console.log(notation, value);\n     *  });\n     *  // \"car.brand\"  \"Dodge\"\n     *  // \"car.model\"  \"Charger\"\n     *  // \"car.year\"  1970\n     */\n    each(callback) {\n        let o = this._source,\n            keys = Object.keys(o);\n        utils.each(keys, (key, index, list) => {\n            // this is preserved in arrow functions\n            let prop = o[key],\n                N;\n            if (utils.isObject(prop)) {\n                N = new Notation(prop);\n                N.each((notation, nKey, value, prop) => {\n                    let subKey = key + '.' + notation;\n                    callback.call(N, subKey, nKey, value, o);\n                });\n            } else {\n                callback.call(this, key, key, prop, o);\n            }\n        });\n    }\n    /**\n     *  Alias for `#each`\n     *  @private\n     */\n    eachKey(callback) {\n        return this.each(callback);\n    }\n\n    /**\n     *  Iterates through each note of the given notation string by evaluating\n     *  it on the source object.\n     *\n     *  @param {String} notation - The notation string to be iterated through.\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each iteration. To break out of the loop, return `false` from within\n     *  the callback.\n     *  Callback signature: `callback(levelValue, note, index, list) { ... }`\n     *\n     *  @returns {void}\n     *\n     *  @example\n     *  var obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  Notation.create(obj)\n     *      .eachValue(\"car.brand\", function (levelValue, note, index, list) {\n     *          console.log(note, levelValue); // \"car.brand\" \"Dodge\"\n     *      });\n     */\n    eachValue(notation, callback) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        var level = this._source;\n        Notation.eachNote(notation, (levelNotation, note, index, list) => {\n            level = utils.hasOwn(level, note) ? level[note] : undefined;\n            if (callback(level, levelNotation, note, index, list) === false) return false;\n\n        });\n    }\n\n    /**\n     *  Gets the list of notations from the source object (keys).\n     *\n     *  @returns {Array} - An array of notation strings.\n     *\n     *  @example\n     *  var obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  var notations = Notation.create(obj).getNotations();\n     *  console.log(notations); // [ \"car.brand\", \"car.model\", \"car.year\" ]\n     */\n    getNotations() {\n        let list = [];\n        this.each((notation, key, value, obj) => {\n            list.push(notation);\n        });\n        return list;\n    }\n\n    /**\n     *  Flattens the source object to a single-level object with notated keys.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  var flat = Notation.create(obj).flatten().value;\n     *  console.log(flat); // { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\n     */\n    flatten() {\n        let o = {};\n        this.each((notation, key, value, obj) => {\n            o[notation] = value;\n        });\n        // return o;\n        this._source = o;\n        return this;\n    }\n\n    /**\n     *  Aggregates notated keys of a (single-level) object, and nests them under\n     *  their corresponding properties. This is the opposite of `Notation#flatten`\n     *  method. This might be useful when expanding a flat object fetched from\n     *  a database.\n     *  @alias Notation#aggregate\n     *  @chainable\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var obj = { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\n     *  var expanded = Notation.create(obj).expand().value;\n     *  console.log(expanded); // { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     */\n    expand() {\n        this._source = Notation.create({}).merge(this._source).value;\n        return this;\n    }\n    /**\n     *  Alias for `#expand`\n     *  @private\n     */\n    aggregate() {\n        return this.expand();\n    }\n\n    /**\n     *  Inspects the given notation on the source object by checking\n     *  if the source object actually has the notated property;\n     *  and getting its value if exists.\n     *\n     *  @param {String} notation - The notation string to be inspected.\n     *\n     *  @returns {InspectResult} - The result object.\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).inspect(\"car.year\");\n     *  // { has: true, value: 1970 }\n     *  Notation.create({ car: { year: 1970 } }).inspect(\"car.color\");\n     *  // { has: false, value: undefined }\n     *  Notation.create({ car: { color: undefined } }).inspect(\"car.color\");\n     *  // { has: true, value: undefined }\n     */\n    inspect(notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        let level = this._source,\n            result = { has: false, value: undefined };\n        Notation.eachNote(notation, (levelNotation, note, index, list) => {\n            if (utils.hasOwn(level, note)) {\n                level = level[note];\n                result = { has: true, value: level };\n            } else {\n                // level = undefined;\n                result = { has: false, value: undefined };\n                return false; // break out\n            }\n        });\n        return result;\n    }\n    /**\n     *  Notation inspection result object.\n     *  @typedef Notation~InspectResult\n     *  @type Object\n     *  @property {Boolean} has - Indicates whether the source object has the given\n     *  notation as a (leveled) enumerable property. If the property exists but has\n     *  a value of `undefined`, this will still return `true`.\n     *  @property {*} value - The value of the notated property. If the source object\n     *  does not have the notation, the value will be `undefined`.\n     */\n\n    /**\n     *  Inspects and removes the given notation from the source object\n     *  by checking if the source object actually has the notated property;\n     *  and getting its value if exists, before removing the property.\n     *\n     *  @param {String} notation - The notation string to be inspected.\n     *\n     *  @returns {InspectResult} - The result object.\n     *\n     *  @example\n     *  var obj = { name: \"John\", car: { year: 1970 } };\n     *  Notation.create(obj).inspectRemove(\"car.year\"); // { has: true, value: 1970 }\n     *  // obj » { name: \"John\", car: {} }\n     *  Notation.create(obj).inspectRemove(\"car.year\", true); // { has: true, value: 1970 }\n     *  // obj » { name: \"John\" }\n     *  Notation.create({ car: { year: 1970 } }).inspectRemove(\"car.color\");\n     *  // { has: false, value: undefined }\n     *  Notation.create({ car: { color: undefined } }).inspectRemove(\"car.color\");\n     *  // { has: true, value: undefined }\n     */\n    inspectRemove(notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        let o, lastNote;\n        if (notation.indexOf('.') < 0) {\n            lastNote = notation;\n            o = this._source;\n        } else {\n            let upToLast = Notation.parent(notation);\n            lastNote = Notation.last(notation);\n            o = this.inspect(upToLast).value;\n        }\n        let result;\n        if (utils.hasOwn(o, lastNote)) {\n            result = { has: true, value: o[lastNote] };\n            delete o[lastNote];\n        } else {\n            result = { has: false, value: undefined };\n        }\n\n        return result;\n    }\n\n    /**\n     *  Checks whether the source object has the given notation\n     *  as a (leveled) enumerable property. If the property exists\n     *  but has a value of `undefined`, this will still return `true`.\n     *\n     *  @param {String} notation - The notation string to be checked.\n     *\n     *  @returns {Boolean}\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).has(\"car.year\"); // true\n     *  Notation.create({ car: { year: undefined } }).has(\"car.year\"); // true\n     *  Notation.create({}).has(\"car.color\"); // false\n     */\n    has(notation) {\n        return this.inspect(notation).has;\n    }\n\n    /**\n     *  Checks whether the source object has the given notation\n     *  as a (leveled) defined enumerable property. If the property\n     *  exists but has a value of `undefined`, this will return `false`.\n     *\n     *  @param {String} notation - The notation string to be checked.\n     *\n     *  @returns {Boolean}\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).hasDefined(\"car.year\"); // true\n     *  Notation.create({ car: { year: undefined } }).hasDefined(\"car.year\"); // false\n     *  Notation.create({}).hasDefined(\"car.color\"); // false\n     */\n    hasDefined(notation) {\n        return this.inspect(notation).value !== undefined;\n    }\n\n    /**\n     *  Gets the value of the corresponding property at the given\n     *  notation.\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *  @param {String} [defaultValue] - The default value to be returned if\n     *  the property is not found or enumerable.\n     *\n     *  @returns {*} - The value of the notated property.\n     *\n     *  @example\n     *  Notation.create({ car: { brand: \"Dodge\" } }).get(\"car.brand\"); // \"Dodge\"\n     *  Notation.create({ car: {} }).get(\"car.model\"); // undefined\n     *  Notation.create({ car: {} }).get(\"car.model\", \"Challenger\"); // \"Challenger\"\n     *  Notation.create({ car: { model: undefined } }).get(\"car.model\", \"Challenger\"); // undefined\n     */\n    get(notation, defaultValue) {\n        let result = this.inspect(notation);\n        return !result.has ? defaultValue : result.value;\n    }\n\n    /**\n     *  Sets the value of the corresponding property at the given\n     *  notation. If the property does not exist, it will be created\n     *  and nested at the calculated level. If it exists; its value\n     *  will be overwritten by default.\n     *  @chainable\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *  @param {*} value - The value to be set for the notated property.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property\n     *  if exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var obj = { car: { brand: \"Dodge\", year: 1970 } };\n     *  Notation.create(obj)\n     *      .set(\"car.brand\", \"Ford\")\n     *      .set(\"car.model\", \"Mustang\")\n     *      .set(\"car.year\", 1965, false)\n     *      .set(\"car.color\", \"red\")\n     *      .set(\"boat\", \"none\");\n     *  console.log(obj);\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\n     */\n    set(notation, value, overwrite = true) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        let level = this._source,\n            last;\n        Notation.eachNote(notation, (levelNotation, note, index, list) => {\n            last = index === list.length - 1;\n            // check if the property is at this level\n            if (utils.hasOwn(level, note)) {\n                // check if we're at the last level\n                if (last) {\n                    // if overwrite is set, assign the value.\n                    if (overwrite) level[note] = value;\n                } else {\n                    // if not, just re-reference the current level.\n                    level = level[note];\n                }\n            } else {\n                // we don't have this property at this level\n                // so; if this is the last level, we set the value\n                // if not, we set an empty object for the next level\n                level = level[note] = (last ? value : {});\n            }\n        });\n        return this;\n    }\n\n    /**\n     *  Just like the `.set()` method but instead of a single notation\n     *  string, an object of notations and values can be passed.\n     *  Sets the value of each corresponding property at the given\n     *  notation. If a property does not exist, it will be created\n     *  and nested at the calculated level. If it exists; its value\n     *  will be overwritten by default.\n     *  @chainable\n     *\n     *  @param {Object} notationsObject - The notations object to be processed.\n     *  This can either be a regular object with non-dotted keys\n     *  (which will be merged to the first/root level of the source object);\n     *  or a flattened object with notated (dotted) keys.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite a property if\n     *  exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var obj = { car: { brand: \"Dodge\", year: 1970 } };\n     *  Notation.create(obj)\n     *      .merge({\n     *          \"car.brand\": \"Ford\",\n     *          \"car.model\": \"Mustang\",\n     *          \"car.year\": 1965,\n     *          \"car.color\": \"red\",\n     *          \"boat\": \"none\"\n     *      });\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\n     */\n    merge(notationsObject, overwrite = true) {\n        if (!utils.isObject(notationsObject)) {\n            throw new NotationError(ERR.NOTA_OBJ + '`' + notationsObject + '`');\n        }\n        let value;\n        utils.each(Object.keys(notationsObject), (notation, index, obj) => {\n            // this is preserved in arrow functions\n            value = notationsObject[notation];\n            this.set(notation, value, overwrite);\n        });\n        return this;\n    }\n\n    /**\n     *  Removes the properties by the given list of notations from the source\n     *  object and returns a new object with the removed properties.\n     *  Opposite of `merge()` method.\n     *\n     *  @param {Array} notations - The notations array to be processed.\n     *\n     *  @returns {Object} - An object with the removed properties.\n     *\n     *  @example\n     *  var obj = { car: { brand: \"Dodge\", year: 1970 }, notebook: \"Mac\" };\n     *  var separated = Notation.create(obj).separate([\"car.brand\", \"boat\" ]);\n     *  console.log(separated);\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\" } };\n     *  console.log(obj);\n     *  // { car: { year: 1970 } };\n     */\n    separate(notations) {\n        if (!utils.isArray(notations)) {\n            throw new NotationError(ERR.NOTA_OBJ + '`' + notations + '`');\n        }\n        let o = new Notation({});\n        utils.each(notations, (notation, index, obj) => {\n            let result = this.inspectRemove(notation);\n            o.set(notation, result.value);\n        });\n        this._source = o._source;\n        return this;\n    }\n\n    // iterate globs\n    // remove non-star negated globs directly\n    // get non-star part iterate thru obj keys\n\n    /**\n     *  Deep clones the source object while filtering its properties\n     *  by the given glob notations. Includes all matched properties\n     *  and removes the rest.\n     *\n     *  @param {Array|String} globNotations - The glob notation(s) to\n     *  be processed. The difference between normal notations and\n     *  glob-notations is that you can use wildcard stars (*) and\n     *  negate the notation by prepending a bang (!). A negated\n     *  notation will be excluded. Order of the globs do not matter,\n     *  they will be logically sorted. Loose globs will be processed\n     *  first and verbose globs or normal notations will be processed\n     *  last. e.g. `[ \"car.model\", \"*\", \"!car.*\" ]` will be sorted as\n     *  `[ \"*\", \"!car.*\", \"car.model\" ]`.\n     *  Passing no parameters or passing an empty string (`\"\"` or `[\"\"]`)\n     *  will empty the source object.\n     *  @chainable\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var obj = { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" } };\n     *  var notation = Notation.create(obj);\n     *  notation.filter([ \"*\", \"!car.*\", \"car.model\" ]);\n     *  console.log(obj); // { notebook: \"Mac\", car: { model: \"Mustang\" } }\n     *  notation.filter(\"*\");\n     *  console.log(obj); // { notebook: \"Mac\", car: { model: \"Mustang\" } }\n     *  notation.filter(); // or notation.filter(\"\");\n     *  console.log(obj); // {}\n     */\n    filter(globNotations) {\n        let original = this.value,\n            copy = utils.deepCopy(original);\n        // if globNotations is \"*\" or [\"*\"] set the \"copy\" as source and\n        // return.\n        if (utils.stringOrArrayOf(globNotations, '*')) {\n            this._source = copy;\n            return this;\n        }\n        // if globNotations is \"\" or [\"\"] set source to `{}` and return.\n        if (arguments.length === 0 || utils.stringOrArrayOf(globNotations, '')) {\n            this._source = {};\n            return this;\n        }\n        let globs = utils.isArray(globNotations)\n            // sort the globs in logical order. we also concat the array first\n            // bec. we'll change it's content via `.shift()`\n            ? NotationGlob.sort(globNotations.concat()) : [globNotations];\n        let filtered;\n        // if the first item of sorted globs is \"*\" we set the source to the\n        // (full) \"copy\" and remove the \"*\" from globs (not to re-process).\n        if (globs[0] === '*') {\n            filtered = new Notation(copy);\n            globs.shift();\n        } else {\n            // otherwise we set an empty object as the source so that we can\n            // add notations/properties to it.\n            filtered = new Notation({});\n        }\n        let g, endStar, normalized;\n        // iterate through globs\n        utils.each(globs, (globNotation, index, array) => {\n            g = new NotationGlob(globNotation);\n            // set flag that indicates whether the glob ends with `.*`\n            endStar = g.normalized.slice(-2) === '.*';\n            // get the remaining part as the (extra) normalized glob\n            normalized = endStar ? g.normalized.slice(0, -2) : g.normalized;\n            // check if normalized glob has no wildcard stars e.g. \"a.b\" or\n            // \"!a.b.c\" etc..\n            if (normalized.indexOf('*') < 0) {\n                if (g.isNegated) {\n                    // directly remove the notation if negated\n                    filtered.remove(normalized);\n                    // if original glob had `.*` at the end, it means remove\n                    // contents (not itself). so we'll set an empty object.\n                    // meaning `some.prop` (prop) is removed completely but\n                    // `some.prop.*` (prop) results in `{}`.\n                    if (endStar) filtered.set(normalized, {}, true);\n                } else {\n                    // directly copy the same notation from the original\n                    filtered.copyFrom(original, normalized, null, true);\n                }\n                // move to the next\n                return true;\n            }\n            // if glob has wildcard star(s), we'll iterate through keys of the\n            // source object and see if (full) notation of each key matches\n            // the current glob.\n\n            // TODO: Optimize the loop below. Instead of checking each key's\n            // notation, get the non-star left part of the glob and iterate\n            // that property of the source object.\n            this.each((originalNotation, key, value, obj) => {\n                // console.log(originalNotation, key);\n                if (g.test(originalNotation)) {\n                    if (g.isNegated) {\n                        filtered.remove(originalNotation);\n                    } else {\n                        filtered.set(originalNotation, value, true);\n                    }\n                }\n            });\n        });\n        // finally set the filtered's value as the source of our instance and\n        // return.\n        this._source = filtered.value;\n        return this;\n    }\n\n    // store.partners.*\n    // *.host » iterate original obj\n    // store.*.host » iterate store obj\n\n    // TODO: remove support for char-star. e.g. `prop1.prop*2`\n\n    /**\n     *  Removes the property at the given notation, from the source object.\n     *  @chainable\n     *\n     *  @param {String} notation - The notation to be inspected.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var obj = { notebook: \"Mac\", car: { model: \"Mustang\" } };\n     *  Notation.create(obj).remove(\"car.model\");\n     *  console.log(obj); // { notebook: \"Mac\", car: { } }\n     */\n    remove(notation) {\n        this.inspectRemove(notation);\n        return this;\n    }\n    // TODO: alias delete\n\n    /**\n     *  Clones the `Notation` instance to a new one.\n     *\n     *  @returns {Notation} - A new copy of the instance.\n     */\n    clone() {\n        let o = utils.deepCopy(this.value);\n        return new Notation(o);\n    }\n\n    /**\n     *  Copies the notated property from the source object and adds it to the\n     *  destination — only if the source object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object} destination - The destination object that the notated\n     *  properties will be copied to.\n     *  @param {String} notation - The notation to get the corresponding property\n     *  from the source object.\n     *  @param {String} [newNotation=null] - The notation to set the source property\n     *  on the destination object. In other words, the copied property will be\n     *  renamed to this value before set on the destination object. If not set,\n     *  `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the destination object if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  var models = { dodge: \"Charger\" };\n     *  Notation.create(obj).copyTo(models, \"car.model\", \"ford\");\n     *  console.log(models);\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\n     *  // obj object is not modified\n     */\n    copyTo(destination, notation, newNotation = null, overwrite = true) {\n        if (!utils.isObject(destination)) throw new NotationError(ERR.DEST);\n        let result = this.inspect(notation);\n        if (result.has) {\n            new Notation(destination).set(newNotation || notation, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Copies the notated property from the destination object and adds it to the\n     *  source object — only if the destination object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object} destination - The destination object that the notated\n     *  properties will be copied from.\n     *  @param {String} notation - The notation to get the corresponding property\n     *  from the destination object.\n     *  @param {String} [newNotation=null] - The notation to set the destination\n     *  property on the source object. In other words, the copied property\n     *  will be renamed to this value before set on the source object.\n     *  If not set, `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property\n     *  on the source object if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  var models = { dodge: \"Charger\" };\n     *  Notation.create(obj).copyFrom(models, \"dodge\", \"car.model\", true);\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\n     *  // models object is not modified\n     */\n    copyFrom(destination, notation, newNotation = null, overwrite = true) {\n        if (!utils.isObject(destination)) throw new NotationError(ERR.DEST);\n        let result = new Notation(destination).inspect(notation);\n        if (result.has) {\n            this.set(newNotation || notation, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Removes the notated property from the source object and adds it to the\n     *  destination — only if the source object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object} destination - The destination object that the notated\n     *  properties will be moved to.\n     *  @param {String} notation - The notation to get the corresponding\n     *  property from the source object.\n     *  @param {String} [newNotation=null] - The notation to set the source property\n     *  on the destination object. In other words, the moved property will be\n     *  renamed to this value before set on the destination object. If not set,\n     *  `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the destination object if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  var models = { dodge: \"Charger\" };\n     *  Notation.create(obj).moveTo(models, \"car.model\", \"ford\");\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\" } }\n     *  console.log(models);\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\n     */\n    moveTo(destination, notation, newNotation = null, overwrite = true) {\n        if (!utils.isObject(destination)) throw new NotationError(ERR.DEST);\n        let result = this.inspectRemove(notation);\n        if (result.has) {\n            new Notation(destination).set(newNotation || notation, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Removes the notated property from the destination object and adds it to the\n     *  source object — only if the destination object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object} destination - The destination object that the notated\n     *  properties will be moved from.\n     *  @param {String} notation - The notation to get the corresponding property\n     *  from the destination object.\n     *  @param {String} [newNotation=null] - The notation to set the destination\n     *  property on the source object. In other words, the moved property\n     *  will be renamed to this value before set on the source object.\n     *  If not set, `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the source object if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  var models = { dodge: \"Charger\" };\n     *  Notation.create(obj).moveFrom(models, \"dodge\", \"car.model\", true);\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\n     *  console.log(models);\n     *  // {}\n     */\n    moveFrom(destination, notation, newNotation = null, overwrite = true) {\n        if (!utils.isObject(destination)) throw new NotationError(ERR.DEST);\n        let result = new Notation(destination).inspectRemove(notation);\n        if (result.has) {\n            this.set(newNotation || notation, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Renames the notated property of the source object by the new notation.\n     *  @alias Notation#renote\n     *  @chainable\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source object.\n     *  @param {String} newNotation - The new notation for the targeted\n     *  property value. If not set, the source object will not be modified.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property at\n     *  the new notation, if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  Notation.create(obj)\n     *      .rename(\"car.brand\", \"carBrand\")\n     *      .rename(\"car.model\", \"carModel\");\n     *  console.log(obj);\n     *  // { carBrand: \"Ford\", carModel: \"Mustang\" }\n     */\n    rename(notation, newNotation, overwrite) {\n        if (!newNotation) return this;\n        return this.moveTo(this._source, notation, newNotation, overwrite);\n    }\n    /**\n     *  Alias for `#rename`\n     *  @private\n     */\n    renote(notation, newNotation, overwrite) {\n        return this.rename(notation, newNotation, overwrite);\n    }\n\n    /**\n     *  Extracts the property at the given notation to a new object by copying\n     *  it from the source object. This is equivalent to `.copyTo({}, notation, newNotation)`.\n     *  @alias Notation#copyToNew\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source object.\n     *  @param {String} newNotation - The new notation to be set on the new\n     *  object for the targeted property value. If not set, `notation` argument\n     *  will be used.\n     *\n     *  @returns {Object} - Returns a new object with the notated property.\n     *\n     *  @example\n     *  var obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  var extracted = Notation.create(obj).extract(\"car.brand\", \"carBrand\");\n     *  console.log(extracted);\n     *  // { carBrand: \"Ford\" }\n     *  // obj is not modified\n     */\n    extract(notation, newNotation) {\n        let o = {};\n        this.copyTo(o, notation, newNotation);\n        return o;\n    }\n    /**\n     *  Alias for `#extract`\n     *  @private\n     */\n    copyToNew(notation, newNotation) {\n        return this.extract(notation, newNotation);\n    }\n\n    /**\n     *  Extrudes the property at the given notation to a new object by moving\n     *  it from the source object. This is equivalent to `.moveTo({}, notation, newNotation)`.\n     *  @alias Notation#moveToNew\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source object.\n     *  @param {String} newNotation - The new notation to be set on the new\n     *  object for the targeted property value. If not set, `notation` argument\n     *  will be used.\n     *\n     *  @returns {Object} - Returns a new object with the notated property.\n     *\n     *  @example\n     *  var obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  var extruded = Notation.create(obj).extrude(\"car.brand\", \"carBrand\");\n     *  console.log(obj);\n     *  // { car: { model: \"Mustang\" } }\n     *  console.log(extruded);\n     *  // { carBrand: \"Ford\" }\n     */\n    extrude(notation, newNotation) {\n        let o = {};\n        this.moveTo(o, notation, newNotation);\n        return o;\n    }\n    /**\n     *  Alias for `#extrude`\n     *  @private\n     */\n    moveToNew(notation, newNotation) {\n        return this.extrude(notation, newNotation);\n    }\n\n    // --------------------------------\n    // Notation Static Methods\n    // --------------------------------\n\n    /**\n     *  Basically constructs a new `Notation` instance with the given object.\n     *  @chainable\n     *\n     *  @param {Object} [object={}] - The object to be notated.\n     *\n     *  @returns {Notation} - The created instance.\n     *\n     *  @example\n     *  var notation = Notation.create(obj);\n     *  // equivalent to:\n     *  var notation = new Notation(obj);\n     */\n    static create(object = {}) {\n        return new Notation(object);\n    }\n\n    /**\n     *  Checks whether the given notation string is valid.\n     *\n     *  @param {String} notation - The notation string to be checked.\n     *\n     *  @returns {Boolean}\n     *\n     *  @example\n     *  Notation.isValid('prop1.prop2.prop3'); // true\n     *  Notation.isValid('prop1'); // true\n     *  Notation.isValid(null); // false\n     */\n    static isValid(notation) {\n        return (typeof notation === 'string') &&\n            (/^[^\\s\\.!]+(\\.[^\\s\\.!]+)*$/).test(notation);\n    }\n\n    /**\n     *  Gets the first (root) note of the notation string.\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *\n     *  @returns {String}\n     *\n     *  @example\n     *  Notation.first('first.prop2.last'); // \"first\"\n     */\n    static first(notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        // return notation.replace(/.*\\.([^\\.]*$)/, '$1');\n        return notation.split('.')[0];\n    }\n\n    /**\n     *  Gets the last note of the notation string.\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *\n     *  @returns {String}\n     *\n     *  @example\n     *  Notation.last('first.prop2.last'); // \"last\"\n     */\n    static last(notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        // return notation.replace(/.*\\.([^\\.]*$)/, '$1');\n        return notation.split('.').reverse()[0];\n    }\n\n    /**\n     *  Gets the parent notation (up to but excluding the last note)\n     *  from the notation string.\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *\n     *  @returns {String}\n     *\n     *  @example\n     *  Notation.parent('first.prop2.last'); // \"first.prop2\"\n     *  Notation.parent('single'); // null\n     */\n    static parent(notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        return notation.indexOf('.') >= 0\n            ? notation.replace(/\\.[^\\.]*$/, '')\n            : null;\n    }\n\n    /**\n     *  Iterates through each note of the given notation string.\n     *\n     *  @param {String} notation - The notation string to be iterated through.\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each iteration. To break out of the loop, return `false` from within the\n     *  callback.\n     *  Callback signature: `callback(levelNotation, note, index, list) { ... }`\n     *\n     *  @returns {void}\n     *\n     *  @example\n     *  Notation.eachNote(\"first.prop2.last\", function (levelNotation, note, index, list) {\n     *      console.log(index, note, levelNotation);\n     *  });\n     *  // 0 \"first\" \"first\"\n     *  // 1 \"first.prop2\" \"prop2\"\n     *  // 2 \"first.prop2.last\" \"last\"\n     */\n    static eachNote(notation, callback) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        let notes = notation.split('.'),\n            levelNotes = [],\n            levelNotation;\n        utils.each(notes, (note, index, list) => {\n            levelNotes.push(note);\n            levelNotation = levelNotes.join('.');\n            if (callback(levelNotation, note, index, notes) === false) return false;\n        }, Notation);\n    }\n\n}\n\n/**\n *  Error class specific to `Notation`.\n *  @private\n *\n *  @class\n *  @see `{@link #Notation.Error}`\n */\nNotation.Error = NotationError;\n\n/**\n *  Utility for validating, comparing and sorting dot-notation globs.\n *  This is internally used by `Notation` class.\n *  @private\n *\n *  @class\n *  @see `{@link #Notation.Glob}`\n */\nNotation.Glob = NotationGlob;\n\n// --------------------------------\n// EXPORT\n// --------------------------------\n\nexport default Notation;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/Notation.js\n **/","\nlet toString = Object.prototype.toString;\n\nconst utils = {\n\n    isObject(o) {\n        return toString.call(o) === '[object Object]';\n    },\n\n    isArray(o) {\n        return toString.call(o) === '[object Array]';\n    },\n\n    hasOwn(o, prop) {\n        return o && typeof o.hasOwnProperty === 'function' && o.hasOwnProperty(prop);\n    },\n\n    deepCopy(object) {\n        if (!utils.isObject(object)) return object;\n        var k, o,\n            copy = {};\n        for (k in object) {\n            if (utils.hasOwn(object, k)) {\n                o = object[k];\n                copy[k] = utils.isObject(o) ? utils.deepCopy(o) : o;\n            }\n        }\n        return copy;\n    },\n\n    // iterates over elements of an array, executing the callback for each\n    // element.\n    each(array, callback, thisArg) {\n        var length = array.length,\n            index = -1;\n        while (++index < length) {\n            if (callback.call(thisArg, array[index], index, array) === false) break;\n        }\n    },\n\n    eachRight(array, callback) {\n        var index = array.length;\n        while (index--) {\n            if (callback(array[index], index, array) === false) break;\n        }\n    },\n\n    // Borrowed from http://phpjs.org/functions/preg_quote\n    pregQuote(str, delimiter) {\n        return String(str)\n            .replace(new RegExp('[.\\\\\\\\+*?\\\\[\\\\^\\\\]$(){}=!<>|:\\\\' + (delimiter || '') + '-]', 'g'), '\\\\$&');\n    },\n\n    stringOrArrayOf(o, value) {\n        return (typeof o === 'string' && o === value)\n            || (utils.isArray(o) && o.length === 1 && o[0] === value);\n    }\n\n};\n\nexport default utils;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/utils.js\n **/","import utils from '../lib/utils';\nimport NotationError from './notation.error';\n\n// http://www.linfo.org/wildcard.html\n// http://en.wikipedia.org/wiki/Glob_%28programming%29\n// http://en.wikipedia.org/wiki/Wildcard_character#Computing\n\n/**\n *  `Notation.Glob` is a utility for validating, comparing and sorting\n *  dot-notation globs.\n *\n *  You can use {@link http://www.linfo.org/wildcard.html|wildcard} stars `*`\n *  and negate the notation by prepending a bang `!`. A star will include all\n *  the properties at that level and a negated notation will be excluded.\n *  @name Notation.Glob\n *  @memberof! Notation\n *  @class\n *\n *  @example\n *  // for the following object;\n *  { name: \"John\", billing: { account: { id: 1, active: true } } };\n *\n *  \"billing.account.*\"  // represents `{ id: 1, active: true }`\n *  \"billing.account.id\" // represents `1`\n *  \"!billing.account.*\" // represents `{ name: \"John\" }`\n *  \"name\" // represents `\"John\"`\n *  \"*\" // represents the whole object\n *\n *  @example\n *  var glob = new Notation.Glob(\"billing.account.*\");\n *  glob.test(\"billing.account.id\"); // true\n */\nclass NotationGlob {\n\n    /**\n     *  Constructs a `Notation.Glob` object with the given glob string.\n     *  @constructs Notation.Glob\n     *\n     *  @param {String} glob - The glob string.\n     */\n    constructor(glob) {\n        if (!NotationGlob.isValid(glob)) {\n            throw new NotationError('Invalid notation glob: \"' + glob + '\"');\n        }\n        this.glob = glob;\n        let ng = NotationGlob.normalize(glob);\n        this.normalized = ng.glob;\n        this.isNegated = ng.isNegated;\n        this.regexp = NotationGlob.toRegExp(this.normalized);\n        this.levels = this.normalized.split('.');\n    }\n\n    // --------------------------------\n    // NotationGlob Instance Members\n    // --------------------------------\n\n    /**\n     *  Checks whether the given notation value matches the source notation glob.\n     *  @name Notation.Glob#test\n     *  @function\n     *\n     *  @param {String} notation - The notation string to be tested.\n     *\n     *  @returns {Boolean}\n     *\n     *  @example\n     *  var glob = new Notation.Glob(\"!prop.*.name\");\n     *  glob.test(\"prop.account.name\"); // true\n     */\n    test(notation) {\n        // we allow \"*\" to match everything. We check for this here\n        // instead of the regexp bec. we care for dots (.) within the glob.\n        return this.normalized === '*'\n            || (this.normalized !== '' && notation !== '' && this.regexp.test(notation));\n    }\n\n    // --------------------------------\n    // NotationGlob Static Members\n    // --------------------------------\n\n    /**\n     *  Basically constructs a new `NotationGlob` instance\n     *  with the given glob string.\n     *  @name Notation.Glob.create\n     *  @function\n     *\n     *  @param {String} glob - The source notation glob.\n     *\n     *  @returns {NotationGlob}\n     *\n     *  @example\n     *  var glob = Notation.Glob.create(strGlob);\n     *  // equivalent to:\n     *  var glob = new Notation.Glob(strGlob);\n     */\n    static create(glob) {\n        return new NotationGlob(glob);\n    }\n\n    /**\n     *  Modified from http://stackoverflow.com/a/13818704/112731\n     *  @private\n     */\n    static toRegExp(glob, opts) {\n        glob = utils.pregQuote(glob).replace(/\\\\\\*/g, '[^\\\\s\\\\.]*').replace(/\\\\\\?/g, '.');\n        return new RegExp('^' + glob, opts || '');\n        // we don't end it with a $ so the ending is open\n        // `company.*` will produce `/^company\\.[^\\s\\.]*/`\n        // which will match both `company.name` and `company.address.street`\n        // but will not match `some.company.name`\n    }\n\n    /**\n     *  @private\n     */\n    static normalize(glob) {\n        // replace multiple stars with single\n        glob = glob.replace(/\\*+/g, '*');\n        // empty glob if invalid e.g. '!' | '.abc' | '!*'\n        glob = !NotationGlob.isValid(glob) ? '' : glob;\n        let bang = glob.slice(0, 1) === '!';\n        glob = bang ? glob.slice(1) : glob;\n        return {\n            glob: glob,\n            isNegated: bang\n        };\n    }\n\n    // Created test at: https://regex101.com/r/tJ7yI9/\n    /**\n     *  Validates the given notation glob.\n     *  @name Notation.Glob.isValid\n     *  @function\n     *\n     *  @param {String} glob - Notation glob to be validated.\n     *  @returns {Boolean}\n     */\n    static isValid(glob) {\n        return (typeof glob === 'string') &&\n            (/^!?[^\\s\\.!]+(\\.[^\\s\\.!]+)*$/).test(glob);\n    }\n\n    // TODO: if both \"prop.id\" and \"!prop.id\" exists normalize them.\n    // since negated will win, remove the other.\n\n    /**\n     *  Compares two given notation globs and returns an integer value as a\n     *  result. This is generally used to sort glob arrays. Loose globs (with\n     *  stars especially closer to beginning of the glob string) and globs\n     *  representing the parent/root of the compared property glob come first.\n     *  Verbose/detailed/exact globs come last. (`* < *abc < abc`). For\n     *  instance; `store.address` comes before `store.address.street`. So this\n     *  works both for `*, store.address.street, !store.address` and\n     *  `*, store.address, !store.address.street`. For cases such as\n     *  `prop.id` vs `!prop.id` which represent the same property;\n     *  the negated glob wins (comes last).\n     *  @name Notation.Glob.compare\n     *  @function\n     *\n     *  @param {String} a - First notation glob to be compared.\n     *  @param {String} b - Second notation glob to be compared.\n     *\n     *  @returns {Number} - Returns `-1` if `a` comes first, `1` if `b` comes\n     *  first and `0` if equivalent priority.\n     *\n     *  @example\n     *  var result = Notation.Glob.compare(\"prop.*.name\", \"prop.*\");\n     *  console.log(result); // 1\n     */\n    static compare(a, b) {\n        // trivial case, both are exactly the same!\n        if (a === b) return 0;\n        let levelsA = a.split('.'),\n            levelsB = b.split('.');\n        // Check depth (number of levels)\n        if (levelsA.length === levelsB.length) {\n            // count wildcards (assuming more wildcards comes first)\n            let wild = /(?:^|\\.)\\*(?:$|\\.)/g,\n                mA = a.match(wild),\n                mB = b.match(wild),\n                wildA = mA ? mA.length : 0,\n                wildB = mB ? mB.length : 0;\n            if (wildA === wildB) {\n                // check for negation\n                let negA = a.indexOf('!') === 0,\n                    negB = b.indexOf('!') === 0;\n                if (negA === negB) {\n                    // both are negated or neither are, just return alphabetical\n                    return a < b ? -1 : 1;\n                }\n                // compare without the negatation\n                let nonNegA = negA ? a.slice(1) : a,\n                    nonNegB = negB ? b.slice(1) : b;\n                if (nonNegA === nonNegB) {\n                    return negA ? 1 : -1;\n                }\n                return nonNegA < nonNegB ? -1 : 1;\n            }\n            return wildA > wildB ? -1 : 1;\n        }\n\n        return levelsA.length < levelsB.length ? -1 : 1;\n    }\n\n    /**\n     *  Sorts the notation globs in the given array by their priorities.\n     *  Loose globs (with stars especially closer to beginning of the glob string);\n     *  globs representing the parent/root of the compared property glob come first.\n     *  Verbose/detailed/exact globs come last. (`* < *abc < abc`). For\n     *  instance; `store.address` comes before `store.address.street`. For cases\n     *  such as `prop.id` vs `!prop.id` which represent the same property; the\n     *  negated glob wins (comes last).\n     *  @name Notation.Glob.sort\n     *  @function\n     *\n     *  @param {Array} globsArray - The notation globs array to be sorted.\n     *  The passed array reference is modified.\n     *\n     *  @returns {Array}\n     *\n     *  @example\n     *  var globs = [\"!prop.*.name\", \"prop.*\", \"prop.id\"];\n     *  Notation.Glob.sort(globs);\n     *  // [\"prop.*\", \"prop.id\", \"!prop.*.name\"];\n     */\n    static sort(globsArray) {\n        return globsArray.sort(NotationGlob.compare);\n        // return _mergeSortArray(globsArray, NotationGlob.compare);\n    }\n\n    /**\n     *  Gets the union from the given couple of glob arrays and returns\n     *  a new array of globs. If the exact same element is found in both\n     *  arrays, one of them is removed to prevent duplicates. If one of the\n     *  arrays contains a negated equivalent of an item in the other array,\n     *  the negated item is removed. If any item covers/matches a negated\n     *  item in the other array, the negated item is removed.\n     *  @name Notation.Glob.union\n     *  @function\n     *\n     *  @param {Array} arrA - First array of glob strings.\n     *  @param {Array} arrB - Second array of glob strings.\n     *  @param {Boolean} [sort=true] - Whether to sort the globs in the final\n     *  array.\n     *\n     *  @returns {Array}\n     *\n     *  @example\n     *  var a = [ 'foo.bar', 'bar.baz', '!*.qux' ],\n     *      b = [ '!foo.bar', 'bar.qux', 'bar.baz' ],\n     *  console.log(Notation.Glob.union(a, b));\n     *  // [ '!*.qux', 'foo.bar', 'bar.baz', 'bar.qux' ]\n     */\n    static union(arrA, arrB, sort) {\n        let nonegA, re, bIndex;\n        // iterate through first array\n        utils.eachRight(arrA, (a, ia) => {\n            // check if the exact item exists in the second array and remove\n            // if exists (to prevent duplicates).\n            bIndex = arrB.indexOf(a);\n            if (bIndex >= 0) arrB.splice(bIndex, 1);\n            // look for negateds and when one found; check if non-negated\n            // equivalent exists in the second array. if it exists, remove\n            // \"this negated\" from first array.\n            // e.g. [ '!foo.bar' ] + [ 'foo.bar' ] => [ 'foo.bar' ]\n            if (a.indexOf('!') === 0) {\n                nonegA = a.slice(1);\n                if (arrB.indexOf(nonegA) >= 0) {\n                    arrA.splice(ia, 1);\n                    return true;\n                }\n                // non-negated is not found in the second. so, iterate through\n                // the second array; look for non-negateds and when found,\n                // check if it covers/matches the negated from the first\n                // array. if so, remove the negated from the first array.\n                // [ '!foo.bar' ] + [ 'foo.*' ]  => [ 'foo.*' ]              // wild covers !v, remove !v\n                // [ 'foo.bar' ]  + [ '!foo.*' ] => [ '!foo.*', 'foo.bar' ]  // !wild covers v, both kept\n                // [ 'baz.que' ]  + [ '!foo.*' ] => [ '!foo.*', 'baz.que' ]  // !wild doesn't cover, both kept\n                utils.eachRight(arrB, (b, ib) => {\n                    if (b.indexOf('!') < 0) {\n                        re = NotationGlob.toRegExp(b);\n                        if (re.test(nonegA)) arrA.splice(ia, 1);\n                    }\n                });\n            } else {\n                // item in the first array is not negated; so check if a\n                // negated equivalent exists in the second and remove if\n                // exists.\n                // e.g. [ 'foo.bar' ] + [ '!foo.bar' ] => [ 'foo.bar' ]\n                bIndex = arrB.indexOf('!' + a);\n                if (bIndex >= 0) arrB.splice(bIndex, 1);\n            }\n        });\n\n        // concat both arrays and sort (if enabled) so we get a nice union\n        // array.\n        let result = arrA.concat(arrB);\n        return (sort === undefined || sort === true)\n            ? NotationGlob.sort(result)\n            : result;\n    }\n\n}\n\nexport default NotationGlob;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/notation.glob.js\n **/","\n// TODO: instanceof return false.\n\n/**\n *  Error class specific to `Notation`.\n *  @name Notation.Error\n *  @memberof! Notation\n *  @class\n *\n */\nclass NotationError extends Error {\n\n    /**\n     *  Initializes a new `Notation.Error` instance.\n     *  @constructs Notation.Error\n     *  @param {String} message - The error message.\n     */\n    constructor(message = '') {\n        super(message);\n        this.name = this.constructor.name;\n\n        Object.defineProperty(this, 'name', {\n            enumerable: false,\n            writable: false,\n            value: 'NotationError'\n        });\n\n        Object.defineProperty(this, 'message', {\n            enumerable: false,\n            writable: true,\n            value: message\n        });\n\n        if (Error.hasOwnProperty('captureStackTrace')) { // V8\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            Object.defineProperty(this, 'stack', {\n                enumerable: false,\n                writable: false,\n                value: (new Error(message)).stack\n            });\n        }\n    }\n}\n\nexport default NotationError;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/notation.error.js\n **/"],"sourceRoot":""}